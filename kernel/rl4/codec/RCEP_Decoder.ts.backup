/******************************************************************************************
 * RCEP_Decoder.ts — Canonical RFC 0.1.0 Decoder / Reconstruction Engine
 *
 * Responsibilities:
 *  - Parse RCEP document (string → RCEPDocument structure)
 *  - Enforce RFC invariants (ordering, formatting, ID consistency)
 *  - Resolve pointers across blocks
 *  - Reconstruct full PromptContext deterministically
 *
 * Guarantees:
 *  - Deterministic decoding (same blob → same structure)
 *  - Strict compliance to RCEP 0.1.0 RFC
 *  - Full pointer resolution with erroring on missing refs
 *  - Validation before returning context
 ******************************************************************************************/

import {
  RCEPDocument,
  RCEPBlock,
  ARCHBlock,
  LAYERSBlock,
  TOPICSBlock,
  TIMELINEBlock,
  DECISIONSBlock,
  INSIGHTSBlock,
  HUMANBlock,
  PromptContext,
  Layer,
  Topic,
  TimelineEvent,
  Decision,
  RCEPInsight
} from "./RCEP_Types";

import { RCEPValidator } from "./RCEP_Validator";
import { RCEPChecksum } from "./RCEP_Checksum";

export interface RCEPDecodeResult {
  document: RCEPDocument;
  context: PromptContext;
  validation: any;
  warnings: string[];
}

export class RCEPDecoder {

  /**
   * Main entry:
   * Convert blob string → PromptContext
   */
  static decode(blob: string): PromptContext {
    const doc = this.parse(blob);

    // Validate doc
    const validation = RCEPValidator.validate(doc);
    if (!validation.valid) {
      throw new Error(`[RCEPDecoder] Invalid document: ${validation.errors.join("; ")}`);
    }

    return this.buildContext(doc);
  }

  /**
   * Decode with full result (for debugging/testing)
   */
  static decodeWithResult(blob: string): RCEPDecodeResult {
    const doc = this.parse(blob);
    const validation = RCEPValidator.validate(doc);

    if (!validation.valid) {
      throw new Error(`[RCEPDecoder] Invalid document: ${validation.errors.join("; ")}`);
    }

    return {
      document: doc,
      context: this.buildContext(doc),
      validation,
      warnings: []
    };
  }

  // ============================================================================
  // PARSE ENTIRE DOCUMENT
  // ============================================================================

  private static parse(blob: string): RCEPDocument {
    const lines = blob.split("\n").map(l => l.trimEnd());

    // Extract checksum (last line before END-RCEP)
    let checksum: string | undefined;
    const endIndex = lines.findIndex(line => line === "END-RCEP");
    if (endIndex > 0 && endIndex > 0 && lines[endIndex - 1].startsWith("checksum:")) {
      checksum = lines[endIndex - 1].substring(9);
    }

    // Content is everything before END-RCEP
    const contentLines = endIndex >= 0 ? lines.slice(0, endIndex) : lines;
    const content = contentLines.join("\n");

    // Header must be first line: "RCEP/0.1.0 <timestamp>"
    const header = contentLines.shift();
    if (!header || !header.startsWith("RCEP/0.1.0")) {
      throw new Error(`[RCEPDecoder] Missing or invalid header`);
    }

    const parts = header.split(" ");
    if (parts.length !== 2) throw new Error(`[RCEPDecoder] Malformed header`);

    const timestamp = Number(parts[1]);
    if (isNaN(timestamp)) throw new Error(`[RCEPDecoder] Invalid timestamp`);

    // Now parse each block
    const doc: RCEPDocument = {
      version: "0.1.0",
      timestamp,
      header: this.parseARCH(contentLines),
      blocks: [
        this.parseLAYERS(contentLines),
        this.parseTOPICS(contentLines),
        this.parseTIMELINE(contentLines),
        this.parseDECISIONS(contentLines),
        this.parseINSIGHTS(contentLines),
        this.tryParseHUMAN(contentLines)
      ].filter(Boolean) as RCEPBlock[],
      checksum
    };

    return doc;
  }

  // ============================================================================
  // BLOCK PARSERS
  // ============================================================================

  private static parseARCH(lines: string[]): ARCHBlock {
    const header = lines.shift();
    if (!header?.startsWith("ARCH:")) {
      throw new Error(`[RCEPDecoder] Expected ARCH block, got: ${header}`);
    }

    const out: any = { id: "ARCH" };

    while (lines[0] && lines[0].includes(":") && !this.isBlockHeader(lines[0])) {
      const line = lines.shift()!;
      const [key, ...valParts] = line.split(":");
      const val = valParts.join(":");
      out[key.replace(/-/g, '')] = val;
    }

    return {
      id: "ARCH",
      sessionId: out["sessionid"] || "",
      llmModel: out["llmmodel"] || "",
      contextWindow: Number(out["contextwindow"]) || 8000,
      compressionAlgo: out["compressionalgo"] || "rcep-v1",
      encodingTime: Number(out["encodingtime"]) || 0,
      ptrScheme: out["ptrscheme"] || "mil-his-v1"
    };
  }

  private static parseLAYERS(lines: string[]): LAYERSBlock {
    const header = lines.shift();
    if (!header?.startsWith("LAYERS:")) {
      throw new Error(`[RCEPDecoder] Expected LAYERS block, got: ${header}`);
    }

    const count = Number(header.split(":")[1]);
    const items: Layer[] = [];

    for (let i = 0; i < count && i < lines.length; i++) {
      const line = lines.shift()!;
      const [id, rest] = line.split(":");
      const [name, weight, parent] = rest.split(",");

      items.push({
        id: Number(id),
        name: name.trim(),
        weight: Number(weight),
        parent: parent === "ROOT" ? "ROOT" : Number(parent)
      });
    }

    return { id: "LAYERS", layers: items };
  }

  private static parseTOPICS(lines: string[]): TOPICSBlock {
    const header = lines.shift();
    if (!header?.startsWith("TOPICS:")) {
      throw new Error(`[RCEPDecoder] Expected TOPICS block, got: ${header}`);
    }

    const count = Number(header.split(":")[1]);
    const items: Topic[] = [];

    for (let i = 0; i < count && i < lines.length; i++) {
      const line = lines.shift()!;
      const [id, rest] = line.split(":");
      const [name, weight, ...refsParts] = rest.split(",");

      const refs = refsParts
        .filter(r => r.trim())
        .map(n => Number(n.trim()))
        .filter(n => !isNaN(n));

      items.push({
        id: Number(id),
        name: name.trim(),
        weight: Number(weight),
        refs
      });
    }

    return { id: "TOPICS", topics: items };
  }

  private static parseTIMELINE(lines: string[]): TIMELINEBlock {
    const header = lines.shift();
    if (!header?.startsWith("TIMELINE:")) {
      throw new Error(`[RCEPDecoder] Expected TIMELINE block, got: ${header}`);
    }

    const count = Number(header.split(":")[1]);
    const events: TimelineEvent[] = [];

    for (let i = 0; i < count && i < lines.length; i++) {
      const line = lines.shift()!;
      const [id, rest] = line.split(":");
      const [timeRaw, type, ptr] = rest.split(",", 3);

      events.push({
        id: Number(id),
        time: Number(timeRaw),
        type: type.trim() as "query" | "response" | "reflection" | "decision",
        ptr: ptr.trim()
      });
    }

    return { id: "TIMELINE", events };
  }

  private static parseDECISIONS(lines: string[]): DECISIONSBlock {
    const header = lines.shift();
    if (!header?.startsWith("DECISIONS:")) {
      throw new Error(`[RCEPDecoder] Expected DECISIONS block, got: ${header}`);
    }

    const count = Number(header.split(":")[1]);
    const items: Decision[] = [];

    for (let i = 0; i < count && i < lines.length; i++) {
      const line = lines.shift()!;
      const [id, rest] = line.split(":");
      const [type, weightRaw, ...inputsRaw] = rest.split(",");

      const inputs = inputsRaw
        .filter(r => r.trim())
        .map(x => Number(x.trim()))
        .filter(n => !isNaN(n));

      items.push({
        id: Number(id),
        type: type.trim() as "accept" | "reject" | "modify" | "defer",
        weight: Number(weightRaw),
        inputs
      });
    }

    return { id: "DECISIONS", decisions: items };
  }

  private static parseINSIGHTS(lines: string[]): INSIGHTSBlock {
    const header = lines.shift();
    if (!header?.startsWith("INSIGHTS:")) {
      throw new Error(`[RCEPDecoder] Expected INSIGHTS block, got: ${header}`);
    }

    const count = Number(header.split(":")[1]);
    const items: RCEPInsight[] = [];

    for (let i = 0; i < count && i < lines.length; i++) {
      const line = lines.shift()!;
      const [id, rest] = line.split(":");
      const [type, salienceRaw, ...linksRaw] = rest.split(",");

      const links = linksRaw
        .filter(r => r.trim())
        .map(x => Number(x.trim()))
        .filter(n => !isNaN(n));

      items.push({
        id: Number(id),
        type: type.trim() as "pattern" | "anomaly" | "correlation" | "causation",
        salience: Number(salienceRaw),
        links
      });
    }

    return { id: "INSIGHTS", insights: items };
  }

  private static tryParseHUMAN(lines: string[]): HUMANBlock | undefined {
    if (!lines[0] || !lines[0].startsWith("HUMAN:")) return undefined;

    const line = lines.shift()!;
    const colonIndex = line.indexOf(":", 6); // Skip "HUMAN:"
    if (colonIndex <= 0) return undefined;

    const type = line.substring(6, colonIndex).trim() as "brief" | "detailed" | "technical";
    const text = line.substring(colonIndex + 1).trim();

    return { id: "HUMAN", summaryType: type, text };
  }

  private static isBlockHeader(line?: string): boolean {
    if (!line) return false;
    return [
      "ARCH:",
      "LAYERS:",
      "TOPICS:",
      "TIMELINE:",
      "DECISIONS:",
      "INSIGHTS:",
      "HUMAN:",
      "END-RCEP"
    ].some(prefix => line.startsWith(prefix));
  }

  // ============================================================================
  // RECONSTRUCT PROMPT CONTEXT
  // ============================================================================

  private static buildContext(doc: RCEPDocument): PromptContext {
    const layersBlock = doc.blocks.find(b => b.id === "LAYERS") as LAYERSBlock;
    const topicsBlock = doc.blocks.find(b => b.id === "TOPICS") as TOPICSBlock;
    const timelineBlock = doc.blocks.find(b => b.id === "TIMELINE") as TIMELINEBlock;
    const decisionsBlock = doc.blocks.find(b => b.id === "DECISIONS") as DECISIONSBlock;
    const insightsBlock = doc.blocks.find(b => b.id === "INSIGHTS") as INSIGHTSBlock;
    const humanBlock = doc.blocks.find(b => b.id === "HUMAN") as HUMANBlock;

    return {
      metadata: {
        sessionId: doc.header.sessionId,
        llmModel: doc.header.llmModel,
        contextWindow: doc.header.contextWindow,
        encodingTime: doc.header.encodingTime,
        ptrScheme: doc.header.ptrScheme as any
      },
      layers: layersBlock?.layers || [],
      topics: topicsBlock?.topics || [],
      timeline: timelineBlock?.events || [],
      decisions: decisionsBlock?.decisions || [],
      insights: insightsBlock?.insights || [],
      humanSummary: humanBlock
        ? { type: humanBlock.summaryType as any, text: humanBlock.text }
        : undefined
    };
  }

  // ============================================================================
  // UTILITIES
  // ============================================================================

  /**
   * Quick validation without full parsing
   */
  static quickValidate(blob: string): { valid: boolean; errors: string[] } {
    const errors: string[] = [];
    const lines = blob.split('\n').map(line => line.trim()).filter(line => line.length > 0);

    if (lines.length < 2) {
      errors.push('Blob too short');
      return { valid: false, errors };
    }

    const header = lines[0];
    if (!header.startsWith('RCEP/')) {
      errors.push('Invalid header format');
    }

    const hasEnd = lines.includes('END-RCEP');
    if (!hasEnd) {
      errors.push('Missing END-RCEP marker');
    }

    return { valid: errors.length === 0, errors };
  }

  /**
   * Get version from blob header
   */
  static getVersion(blob: string): string | null {
    const lines = blob.split('\n');
    const header = lines[0]?.trim();
    const match = header?.match(/^RCEP\/(\d+\.\d+\.\d+)/);
    return match ? match[1] : null;
  }
}