/******************************************************************************************
 * RCEP_Validator.ts — Strict RFC 0.1.0 Compliance Validator
 *
 * Enforces:
 *  - Canonical RCEP structure
 *  - Schema correctness
 *  - Pointer validity
 *  - Weight/salience constraints
 *  - Timestamp ordering
 *  - UTF-8, LF-only, no forbidden chars
 *  - Deterministic checksum validation
 *
 * This is the firewall of the RCEP protocol.
 ******************************************************************************************/

import {
  RCEPDocument,
  RCEPBlock,
  ARCHBlock,
  LAYERSBlock,
  TOPICSBlock,
  TIMELINEBlock,
  DECISIONSBlock,
  INSIGHTSBlock,
  HUMANBlock,
  Layer,
  Topic,
  TimelineEvent,
  Decision,
  RCEPInsight
} from "./RCEP_Types";
import { RCEPChecksum } from "./RCEP_Checksum";

export interface RCEPValidationResult {
  valid: boolean;
  errors: string[];
  warnings: string[];
}

export class RCEPValidator {

  /**
   * Validate entire RCEP document according to RFC 0.1.0.
   */
  static validate(doc: RCEPDocument): RCEPValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    // 1. Block presence and basic structure
    this.validateDocumentStructure(doc, errors, warnings);

    if (errors.length > 0) {
      return { valid: false, errors, warnings };
    }

    // 2. Extract blocks for validation
    const archBlock = this.extractBlock(doc, "ARCH") as ARCHBlock;
    const layersBlock = this.extractBlock(doc, "LAYERS") as LAYERSBlock;
    const topicsBlock = this.extractBlock(doc, "TOPICS") as TOPICSBlock;
    const timelineBlock = this.extractBlock(doc, "TIMELINE") as TIMELINEBlock;
    const decisionsBlock = this.extractBlock(doc, "DECISIONS") as DECISIONSBlock;
    const insightsBlock = this.extractBlock(doc, "INSIGHTS") as INSIGHTSBlock;
    const humanBlock = this.extractBlock(doc, "HUMAN") as HUMANBlock | undefined;

    // 3. Validate each block
    this.validateARCH(archBlock, errors);
    this.validateLAYERS(layersBlock, errors);
    this.validateTOPICS(topicsBlock, layersBlock, errors);
    this.validateTIMELINE(timelineBlock, errors);
    this.validateDECISIONS(decisionsBlock, timelineBlock, errors);
    this.validateINSIGHTS(insightsBlock, errors);
    if (humanBlock) {
      this.validateHUMAN(humanBlock, errors);
    }

    // 4. Cross-block pointer integrity
    this.validatePointers(
      layersBlock,
      topicsBlock,
      timelineBlock,
      decisionsBlock,
      insightsBlock,
      errors
    );

    // 5. Timestamp invariants
    this.validateTimestamps(timelineBlock, errors);

    // 6. Checksum verification
    if (doc.checksum) {
      if (!RCEPChecksum.verify(doc)) {
        errors.push("Checksum mismatch: document has been altered or corrupted");
      }
    } else {
      warnings.push("No checksum found: integrity cannot be guaranteed");
    }

    // 7. RFC invariants (UTF-8, LF-only, etc.)
    this.validateRFCInvariants(doc, errors);

    return {
      valid: errors.length === 0,
      errors,
      warnings
    };
  }

  // ============================================================================
  // STRUCTURE VALIDATION
  // ============================================================================

  private static validateDocumentStructure(
    doc: RCEPDocument,
    errors: string[],
    warnings: string[]
  ): void {
    // Version check
    if (!doc.version || doc.version !== "0.1.0") {
      errors.push(`Invalid or missing version: ${doc.version}, expected: 0.1.0`);
    }

    // Timestamp check
    if (!doc.timestamp || doc.timestamp <= 0) {
      errors.push("Invalid or missing timestamp: must be positive Unix epoch");
    }

    // Blocks array check
    if (!Array.isArray(doc.blocks)) {
      errors.push("Invalid blocks: must be an array");
      return;
    }

    // Required blocks check
    const requiredBlocks = ["ARCH", "LAYERS", "TOPICS", "TIMELINE", "DECISIONS", "INSIGHTS"];
    const blockIds = doc.blocks.map(b => b.id);

    for (const required of requiredBlocks) {
      if (!blockIds.includes(required)) {
        errors.push(`Missing required block: ${required}`);
      }
    }
  }

  private static extractBlock(doc: RCEPDocument, blockId: string): RCEPBlock | null {
    return doc.blocks.find(b => b.id === blockId) || null;
  }

  // ============================================================================
  // BLOCK VALIDATORS
  // ============================================================================

  private static validateARCH(arch: ARCHBlock, errors: string[]): void {
    if (!arch) {
      errors.push("ARCH block is null");
      return;
    }

    if (!arch.sessionId || arch.sessionId.trim().length === 0) {
      errors.push("ARCH: missing or empty sessionId");
    }

    if (!arch.llmModel || arch.llmModel.trim().length === 0) {
      errors.push("ARCH: missing or empty llmModel");
    }

    if (!arch.contextWindow || arch.contextWindow <= 0) {
      errors.push("ARCH: contextWindow must be > 0");
    }

    if (!["rcep-v1", "rcep-v2"].includes(arch.compressionAlgo)) {
      errors.push(`ARCH: invalid compressionAlgo: ${arch.compressionAlgo}`);
    }

    if (!["mil-his-v1", "internal-v1"].includes(arch.ptrScheme)) {
      errors.push(`ARCH: invalid ptrScheme: ${arch.ptrScheme}`);
    }

    if (!arch.encodingTime || arch.encodingTime <= 0) {
      errors.push("ARCH: encodingTime must be > 0");
    }
  }

  private static validateLAYERS(layers: LAYERSBlock, errors: string[]): void {
    if (!layers) {
      errors.push("LAYERS block is null");
      return;
    }

    const ids = new Set<number>();

    for (const layer of layers.layers) {
      if (ids.has(layer.id)) {
        errors.push(`LAYERS: duplicate layer ID ${layer.id}`);
      }
      ids.add(layer.id);

      if (layer.weight < 0 || layer.weight > 999) {
        errors.push(`LAYERS: invalid weight ${layer.weight} for layer ${layer.id}`);
      }

      if (layer.parent !== "ROOT" && typeof layer.parent === "number" && layer.parent < 0) {
        errors.push(`LAYERS: invalid parent ${layer.parent} for layer ${layer.id}`);
      }
    }
  }

  private static validateTOPICS(
    topics: TOPICSBlock,
    layers: LAYERSBlock,
    errors: string[]
  ): void {
    if (!topics) {
      errors.push("TOPICS block is null");
      return;
    }

    const layerIds = new Set(layers?.layers.map(l => l.id) || []);
    const topicIds = new Set<number>();

    for (const topic of topics.topics) {
      if (topicIds.has(topic.id)) {
        errors.push(`TOPICS: duplicate topic ID ${topic.id}`);
      }
      topicIds.add(topic.id);

      if (topic.weight < 0 || topic.weight > 999) {
        errors.push(`TOPICS: invalid weight ${topic.weight} for topic ${topic.id}`);
      }

      // Validate refs point to existing layers
      for (const ref of topic.refs) {
        if (!layerIds.has(ref)) {
          errors.push(`TOPICS: topic ${topic.id} references unknown layer ${ref}`);
        }
      }
    }
  }

  private static validateTIMELINE(timeline: TIMELINEBlock, errors: string[]): void {
    if (!timeline) {
      errors.push("TIMELINE block is null");
      return;
    }

    const ids = new Set<number>();
    const validTypes = ["query", "response", "reflection", "decision"];

    for (const ev of timeline.events) {
      if (ids.has(ev.id)) {
        errors.push(`TIMELINE: duplicate event ID ${ev.id}`);
      }
      ids.add(ev.id);

      if (!validTypes.includes(ev.type)) {
        errors.push(`TIMELINE: invalid event type "${ev.type}" for event ${ev.id}`);
      }

      if (!ev.time || ev.time <= 0) {
        errors.push(`TIMELINE: invalid timestamp ${ev.time} for event ${ev.id}`);
      }

      if (!ev.ptr || ev.ptr.trim().length === 0) {
        errors.push(`TIMELINE: invalid or empty ptr for event ${ev.id}`);
      }
    }
  }

  private static validateDECISIONS(
    decisions: DECISIONSBlock,
    timeline: TIMELINEBlock,
    errors: string[]
  ): void {
    if (!decisions) {
      errors.push("DECISIONS block is null");
      return;
    }

    const timelineIds = new Set(timeline?.events.map(e => e.id) || []);
    const decisionIds = new Set<number>();
    const validTypes = ["accept", "reject", "modify", "defer"];

    for (const d of decisions.decisions) {
      if (decisionIds.has(d.id)) {
        errors.push(`DECISIONS: duplicate decision ID ${d.id}`);
      }
      decisionIds.add(d.id);

      if (!validTypes.includes(d.type)) {
        errors.push(`DECISIONS: invalid type "${d.type}" for decision ${d.id}`);
      }

      if (d.weight < 0 || d.weight > 999) {
        errors.push(`DECISIONS: invalid weight ${d.weight} for decision ${d.id}`);
      }

      // Validate inputs reference timeline events
      for (const input of d.inputs) {
        if (!timelineIds.has(input)) {
          errors.push(`DECISIONS: decision ${d.id} references non-existent event ${input}`);
        }
      }
    }
  }

  private static validateINSIGHTS(insights: INSIGHTSBlock, errors: string[]): void {
    if (!insights) {
      errors.push("INSIGHTS block is null");
      return;
    }

    const insightIds = new Set<number>();
    const validTypes = ["pattern", "anomaly", "correlation", "causation"];

    for (const i of insights.insights) {
      if (insightIds.has(i.id)) {
        errors.push(`INSIGHTS: duplicate insight ID ${i.id}`);
      }
      insightIds.add(i.id);

      if (!validTypes.includes(i.type)) {
        errors.push(`INSIGHTS: invalid type "${i.type}" for insight ${i.id}`);
      }

      if (i.salience < 0 || i.salience > 999) {
        errors.push(`INSIGHTS: invalid salience ${i.salience} for insight ${i.id}`);
      }
    }
  }

  private static validateHUMAN(human: HUMANBlock, errors: string[]): void {
    if (!human) {
      errors.push("HUMAN block is null");
      return;
    }

    const validTypes = ["brief", "detailed", "technical"];
    if (!validTypes.includes(human.summaryType)) {
      errors.push(`HUMAN: invalid summary type "${human.summaryType}"`);
    }

    if (!human.text) {
      errors.push("HUMAN: missing text content");
    }

    // Length validation
    const maxLength = human.summaryType === "brief" ? 200 :
                     human.summaryType === "detailed" ? 1000 : 2000;

    if (human.text.length > maxLength) {
      errors.push(`HUMAN: text too long (${human.text.length} > ${maxLength}) for ${human.summaryType}`);
    }
  }

  // ============================================================================
  // POINTER VALIDATION
  // ============================================================================

  private static validatePointers(
    layers: LAYERSBlock,
    topics: TOPICSBlock,
    timeline: TIMELINEBlock,
    decisions: DECISIONSBlock,
    insights: INSIGHTSBlock,
    errors: string[]
  ): void {
    const layerIds = new Set(layers?.layers.map(l => l.id) || []);
    const topicIds = new Set(topics?.topics.map(t => t.id) || []);
    const timelineIds = new Set(timeline?.events.map(e => e.id) || []);
    const decisionIds = new Set(decisions?.decisions.map(d => d.id) || []);
    const insightIds = new Set(insights?.insights.map(i => i.id) || []);

    // Validate event.ptr → block:element
    if (timeline) {
      for (const ev of timeline.events) {
        const [block, idStr] = ev.ptr.split(":");
        const id = Number(idStr);

        if (block === "HISTORY") continue; // external pointer (allowed)

        if (block === "LAYER") {
          if (!layerIds.has(id)) {
            errors.push(`TIMELINE: event ${ev.id} ptr references unknown layer ${id}`);
          }
        }

        if (block === "TOPIC") {
          if (!topicIds.has(id)) {
            errors.push(`TIMELINE: event ${ev.id} ptr references unknown topic ${id}`);
          }
        }

        if (block === "DECISION") {
          if (!decisionIds.has(id)) {
            errors.push(`TIMELINE: event ${ev.id} ptr references unknown decision ${id}`);
          }
        }

        if (block === "INSIGHT") {
          if (!insightIds.has(id)) {
            errors.push(`TIMELINE: event ${ev.id} ptr references unknown insight ${id}`);
          }
        }
      }
    }

    // Validate insight.links
    if (insights) {
      for (const insight of insights.insights) {
        for (const link of insight.links) {
          if (!insightIds.has(link)) {
            errors.push(`INSIGHTS: insight ${insight.id} links to unknown insight ${link}`);
          }
        }
      }
    }
  }

  // ============================================================================
  // TIMESTAMP VALIDATION
  // ============================================================================

  private static validateTimestamps(timeline: TIMELINEBlock, errors: string[]): void {
    if (!timeline || timeline.events.length <= 1) return;

    const times = timeline.events.map(e => e.time);

    for (let i = 1; i < times.length; i++) {
      if (times[i] < times[i - 1]) {
        errors.push(
          `TIMELINE: timestamp disorder at event ${timeline.events[i].id} (${times[i]} < ${times[i - 1]})`
        );
      }
    }
  }

  // ============================================================================
  // RFC INVARIANTS VALIDATION
  // ============================================================================

  private static validateRFCInvariants(doc: RCEPDocument, errors: string[]): void {
    // Convert to string to check for forbidden characters
    const docStr = JSON.stringify(doc);

    // Check for control characters (except allowed ones)
    const controlChars = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x9F]/g;
    if (controlChars.test(docStr)) {
      errors.push("Document contains forbidden control characters");
    }

    // Check for proper UTF-8 (should be guaranteed by JSON.stringify but still worth noting)
    try {
      Buffer.from(docStr, 'utf8');
    } catch (e) {
      errors.push("Document contains invalid UTF-8 sequences");
    }
  }
}